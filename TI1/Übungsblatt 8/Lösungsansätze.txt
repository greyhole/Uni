Bei 8.2 (a) [i] hab ich schon in verschiedene Richtungen überlegt. Mit Automaten oder Reg Ausdrücken geht’s auf keinen Fall, Alternative vllt mit Typ3 Grammatiken.
Wichtig ist halt, dass alle verschiedenen Möglichkeiten die Wörter zu trennen drin sein müssen und die Teilwörter ele Sigma* sind, also hat jedes Wort unendlich Möglichkeiten getrennt zu werden (sobald man halt epsilon als Teilwort nimmt).
Ähnlich bei [ii], wo dann auch alle Wörter in L1 an jeder Stelle getrennt werden können und dann jeweils andersrum wieder zusammengefügt werden. Da ist es wenigstens auf 2 Teilwörter beschränkt.


Bei 8.2  a+b hab ich auch keinen schimmer wie ich das aufschreiben soll.


Fällt dir denn irgendwie ein, wie man die Sprachen mit einer der Sachen Beschreiben könnte? Also so ein Vorher nachher ding. Aus E + E wird folgendes … Aus E* wird das.. Also so wie in den Folien. Weißt du was ich meine? Ich würd jetzt wirklich gerne ins bett gehen.




8.2 (b) [i] L1 geschnitten mit 0*1* gibt L01 (also die Sprache 0^n 1^n), also ist L1 nicht regulär.                                
Siehe slides 2.5 Seite 14 Anwendungsbeispiele.
[ii] Erst holt man per Homomorphismus die 2 raus. Dann bleibt 0^k 1^m |  m = 3k + 1.
Dann könnte man das Pumping Lemma benutzen. Mehr fällt mir auch nicht ein.
EDIT: Man macht das mit Urbild unter Homormophismus h: h(0) = 0, h(1) = 111
Und das wäre dann dasselbe wie 0^k 1^k,aber dann muss vorher das +1 da weg, sonst gibt das Urbild die Leere Menge. 3k+1 geht nicht durch 3. Also wie kriegt man das +1 da weg?
Ich bin pro Pumping Lemma


Ich fang unten damit an


vllt garnicht, und sie ist regulär…
Als ob.. die ist doch sehr unregulär wenn du mich fragst :D hab ich nicht rausgehört ^^
war aber so gemeint.
deswegen auch die sms…

das muss doch irgendwie zu vereinfachen sein der scheiß


:D
ja klar...war eher ironisch… 
8.2 (c) L_i = {0^i 1^i} also die Sprache L_i besteht aus dem Wort 0..0 1..1 (i-mal 0, dann i-mal 1). Dann ist die Vereinigung aller Sprachen mit i ele N die Sprache L01 (also die Sprache 0^n 1^n), die ja bekannterweise nicht regulär ist.


8.3 L := {ww^R} ist regulär, g.d.w. Sigma* / L endlich ist bzw.
      L := {ww^R} ist NICHT regulär, g.d.w. Sigma* / L unendlich ist.


Äquivalenzklassen
[epsilon]_L = {u ele {a,b}* | u ~_L epsilon} = {epsilon}
[a]_L = {u | (A) w. uw ele L ⇔ aw ele L}
        = {u | (A) w. uw ele L ⇔ (E) v ele L. w = va} = {a}
[b]_L = {u | (A) w. uw ele L ⇔ bw ele L}
        = {u | (A) w. uw ele L ⇔ (E) v ele L. w = vb} = {b}
[aa]_L = ... = {u | (A) w. uw ele L ⇔ (E) v ele L. w = vaa} = {aa}
[ab]_L = … = {u | (A) w. uw ele L ⇔ (E) v ele L. w = vba} = {ab}
.
.
.
Am besten siehst du dir nochmal die Folien 2.5 an (vorletzte Seite) bevor du das aufschreibst


EDIT zur 8.3: Man soll da die Entwicklung beobachten können, das werden unendlich viele Äquivalenzklassen und deswegen gilt der Myhill/Nerode Satz vom 2.5 Anhang.


hmmm
nagut
mir fällt ja auch nichts ein




jo alles klar
hab mir  das Pumping lemma heute schon öfter angeschaut
ich male dann auch noch den graphen…
Gute nacht
bin morgen ab 11 in der uni


Perfekt :) Bin dann jetzt off dir auch.
Pumping Lemma 8.2 b) ii)
L = { 0^k 1^m |  m = 3k + 1 }


Dann sei n beliebig


Unser Wort sei 0^n 1^(3n+1)
Dann ist x = 0^i, y = 0^j und z = 0^(n-i-j) 1^(3n+1)
Dann darf ich y^k nehmen. k ist 0.
Dann ist das Wort nicht in der Sprache.
( w = 0^(n-j) 1^(3n+1) nicht ele L)