#include "systemc.h"

#ifndef CONSUMER_H_
#define CONSUMER_H_
#define IDLE 0
#define UP 1
#define DOWN 2

SC_MODULE(Consumer){

	sc_out<int> cFloor,cState;
	sc_out<bool> carry;
	sc_vector< sc_in< sc_bv< 1 > > > upList,downList;
	int lastDirection;

	SC_CTOR(Consumer){
		lastDirection = 2;
		upList.init(4);
		downList.init(4);
		cFloor.initialize(0);
		cState.initialize(IDLE);
		carry.initialize(false);
		SC_THREAD(consume);

		for( uint i = 0;i<4;i++){
			sensitive << upList[i] << downList[i];
		}
	}

	void consume(){
		while(true){
			cout << "consume" << endl;
			int lowDown,highUp;
			switch(cState){
				case IDLE:
					cout << "consume.IDLE" << endl;
					lowDown = checkDownList();
					highUp = checkUpList();
					if ((lowDown != -1) & (highUp != -1)){
						if(lastDirection == 2){
							cout << "consume.IDLE.lastDir=2";
							cState = UP;
							lastDirection = 1;
							carry = false;
						}
						else{
							lastDirection = 2;
							cState = DOWN;
							carry = false;
						}
						wait(2,SC_SEC);
					}
					else if((lowDown == -1) & (highUp != -1)){
						cout << "consume.IDLE.highUp" << endl;
						lastDirection = 1;
						cState = UP;
						carry = false;
						wait(2,SC_SEC);
					}
					else if((lowDown != -1) & (highUp == -1)){
						lastDirection = 2;
						cState = DOWN;
						carry = false;
						wait(2,SC_SEC);
					}
					break;
				case UP:
					cout << cState;
					wait();
					break;
				case DOWN:
					cout << cState;
					wait();
					break;
				default:
					wait();
				}
		}
	}

	int checkUpList(){
		int tmp = -1;
		for(uint i(cFloor);i < upList.size();i++){
			if(upList[i].read()== "1"){
				tmp = i;
			}
		}
		return tmp;
	}

	int checkDownList(){
		int tmp = -1;
		for(int i(cFloor);i >= 0 ;i--){
			if(downList[i].read() == "1"){
				tmp = i;
			}
		}
		return tmp;
	}
};

#endif
